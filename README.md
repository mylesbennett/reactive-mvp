# README #
This is an exploration of Reactive MVP principles in combination with Kotlin-specific dependancy injection, written as an Android technical test. The original specification pdf is in the repository alongside this readme.
## Main Ingredients ##
- Reactive MVP https://medium.com/@mvarnagiris/reactive-mvp-part-1-b751ce3e3246
- Rx Binding https://github.com/JakeWharton/RxBinding
- Kodein dependancy injection http://kodein.org/Kodein-DI/?6.0
- Android Lifecycleobserver https://developer.android.com/reference/android/arch/lifecycle/LifecycleObserver
- Retrofit 2 https://square.github.io/retrofit/
## Architecture over Graphics
##### Reason 1 #####
Almost all of the projects that I have worked on in recent years have diligently pursued architectures that have attempted to decouple code, aiding easier testing and work-sharing. All of them have had way more boiler-plate set-up for new features than I have liked. For some time now I have wanted to find an architecture with minimal new feature setup that required neither a large amount of boiler-plate code nor over-burdoned unportable base classes. One of the "50 ways" Java recommendations states 'prefer containment (or delegation) over inheritance' and yet the whole basis of Android development is on inheritance from Google's base classes. Google have finally addressed that problem. They can't rewrite all of their base code but their workaround in the form of the LifecycleObserver is certainly a good effort (They just need to extend that to View classes now). Please take a look at my PresenterDelegate class. This is a portable delegate that works for both Fragments and Activities - no abstract class inheritance required.

A good architecture is the foundation of a successful project. Good graphics is just lipstick. A good architecture will decouple the graphics completely from the business logic making it easier to test-drive pretty animations etc. 

##### Reason 2 #####
Gettings graphics just right is a rabbit-hole for me. I will disappear down that hole and never be seen again. Whilst the time limit for submission for this is reasonably flexible, I didn't want to be still fiddling with it in a fortnight's time. I'm already a day later than I said I would be.

I realise the graphics for this are awful. I begrudgingly added the line of code to add the RecyclerView item divider that Google had neglected to provide as part of the XML specification (like they did with ListViews) but I just couldn't be bothered to add the XML and corresponding code to control a progress bar display whilst the item details are loading. Maybe one day I'll write some white-label arrangement for this. It's difficult, though, since custom View development is reliant on inheritance from a multitude of View derivatives. Again, Google, 'prefer delegation over inheritance'. This paradigm pre-dates your OS. What were you thinking?
## Dude, where's your Dagger? ##
I have been rejected from at least two positions at interview because I opened my big mouth and expressed my loathing for Dagger2. I really don't enjoy having to update the code in three, sometimes four different places - which you need to look for in complex code-bases - just to add a new feature. And since Studio 3.2 you don't even get a useful message about where you messed it up. Furthermore, we have a new, much better language to develop with now. It's called 'Kotlin'. Do we really want to be using a DI library that was developed for an obsolete language that auto-generates a truck-load of code in said obsolete language to help blow-out your procedure limit and your apk size? Or would you rather use a library that leverages the power of your shiny new language and doesn't need to rely on annotations? This is why I used Kodein. When you add a new feature in my arrangement here, you add one line of code to your bindings file then one, possibly two lines of code (depending on whether or not there are existing injections) to the point of injection. I struggled with Kodein on this test. There is precious little documentation regarding mock substitution, their 'ConfigurableKodein' is simply not configurable and their 'import module' arrangement actaully causes a run-time crash, but I still prefer it to Dagger. After much digging, I believe I found acceptable workarounds for these issues anyway.
## Criticism so far ##
I recently had an interview in which I had to demonstrate some work. I can't show anything I've done for clients due to NDA's so I showed them this as work-in-progress. In one place I had created a 'viewReady' event that triggered the fetching of data. My interviewer quite rightly pointed out that this should be unecessary and that the architecture should take care of this. In fact, it already did. I only put it in over paranoia from view-not-ready crashes in years gone by. I thanked her for peer-review and assured her that it would be removed. Unfortunately, she then fixated on that for the rest of the interview and made the following criticisms that I probably did not adequately respond to at the time.
##### Your presenter is dependant on your view's lifecycle #####
No, it's not, although I can see why she might have thought that. Apart from the 'viewReady' gaff, the presenter has methods called 'attach' and 'detach' called by the view and 'attach' has an abstract method called by attach called 'onAttach' that looks a lot like the Fragment lifecycle callback of the same name. In fact, these calls are more akin to constructor and destructor calls of non-garbage-collected languages such as C++. They take care of observable subscription and subsequent disposal - nothing more. It's up to the view when they're called, which just happens to conveniently correspond with 'start' and 'stop' lifecycle callbacks on both Fragments and Activities.
##### Your presenter is dependant on your view - violating the 'D' principle in SOLID #####
No, it is **so** not. If you take a look at the top-level structure in Studio, you will see that there are three modules:- 'Model', 'View' and 'Presenter'. If you look at the build.gradle files for those modules you will see that View imports Presenter and Presenter only imports Model. I deliberately set it up this way to guard against exactly this. If you try to write code in the presenter that uses code in the view the IDE will immedeately complain. I gujess you could argue that there is a **run-time** dependancy between the view and the presenter. The presenter won't actually do anything until the view needs it but then that is the same for any plugin or library. 'fun doSomethingWith(input1, input2)' in any library won't do anything unless the parent using it calls it.
##### Your arrangement does not facilitate scaling. There will be many code conflict issues with multiple team members #####
She probably got this idea because I had all of the bindings in the Application class. At the time I was still struggling with the 'import module' arrangement that is the prescribed method of abstracting this away and splitting it up. I think the workaround that uses the receiver value that is now in place works just as well (see PresenterBindings file).
##### You can't attach a presenter to an Android View class derivative #####
Yes you can. I admit that using the presenterDelegate helper may be tricky because View does not have it's own lifecycle observer. You might be able to grab a lifecycle from upstream with a lateinit but this is likely to be messy. It'd probably better to just inject the presenter directly into the View and then manually call attach and detach in onViewAttach and onViewDetach respectively, as described by *mvarnagiris* here:- https://medium.com/@mvarnagiris/reactive-mvp-part-2-7700a0284b4b
## Setup ##
I've excluded all of the Studio-specific files so you need to 'Import from Gradle' when loading into Android Studio. I haven't actually tried to build it from the command-line but since Studio can import it from the Gradle files, I can't see any reason why those same files wouldn't allow a build from the command-line.